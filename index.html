<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Forex Trading Signals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Basic styling */
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      text-align: center;
      padding: 20px;
      margin: 0;
    }
    h1 {
      margin-bottom: 10px;
    }
    .signal {
      font-size: 2em;
      margin-top: 20px;
    }
    .buy { color: green; }
    .sell { color: red; }
    .no-entry { color: gray; }
  </style>
  <!-- Load technical indicators library from CDN -->
  <script src="https://unpkg.com/technicalindicators@3.1.0/dist/browser/technicalindicators.js"></script>
</head>
<body>
  <h1>Forex Trading Signals</h1>
  <div id="signal" class="signal">Loading...</div>

  <script>
    // ============================
    // Configuration
    // ============================
    const API_KEY = '7f14401130ba4919be6fcc897e89623f'; // Replace with your Twelve Data API key
    const SYMBOL = 'EUR/JPY'; // Change to 'CHF/JPY' if desired, or duplicate the logic for both pairs
    const INTERVAL = '1min';
    const OUTPUT_SIZE = 60; // Last 60 minutes

    // Construct the Twelve Data time series endpoint URL
    const TIME_SERIES_URL = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(SYMBOL)}&interval=${INTERVAL}&outputsize=${OUTPUT_SIZE}&apikey=${API_KEY}`;

    // ============================
    // Helper: Fetch time series data
    // ============================
    async function fetchTimeSeries() {
      try {
        const response = await fetch(TIME_SERIES_URL);
        const data = await response.json();
        if (data && data.values) {
          // Twelve Data returns newest first â€“ reverse so oldest is first
          return data.values.reverse();
        } else {
          console.error('Time series error:', data);
          return null;
        }
      } catch (error) {
        console.error('Fetch error:', error);
        return null;
      }
    }

    // ============================
    // Helper: Compute VWAP manually
    // VWAP = (Sum(typicalPrice * volume)) / (Sum(volume))
    // where typicalPrice = (high + low + close)/3
    // ============================
    function computeVWAP(data) {
      let cumulativePV = 0, cumulativeVolume = 0;
      data.forEach(bar => {
        const high = parseFloat(bar.high);
        const low = parseFloat(bar.low);
        const close = parseFloat(bar.close);
        const volume = parseFloat(bar.volume);
        const typicalPrice = (high + low + close) / 3;
        cumulativePV += (typicalPrice * volume);
        cumulativeVolume += volume;
      });
      return cumulativeVolume ? cumulativePV / cumulativeVolume : null;
    }

    // ============================
    // Calculate indicators and derive individual signals
    // ============================
    function determineIndicatorSignals(data) {
      // Prepare arrays from time series
      const closes = data.map(bar => parseFloat(bar.close));
      const highs  = data.map(bar => parseFloat(bar.high));
      const lows   = data.map(bar => parseFloat(bar.low));
      
      // Current price is the last close
      const currentPrice = closes[closes.length - 1];

      // Calculate EMA(9)
      const emaArray = technicalindicators.EMA.calculate({ period: 9, values: closes });
      const ema9 = emaArray[emaArray.length - 1];

      // Calculate RSI(14)
      const rsiArray = technicalindicators.RSI.calculate({ period: 14, values: closes });
      const rsi = rsiArray[rsiArray.length - 1];

      // Calculate MACD (fast=12, slow=26, signal=9)
      const macdArray = technicalindicators.MACD.calculate({
        values: closes,
        fastPeriod: 12,
        slowPeriod: 26,
        signalPeriod: 9,
        SimpleMAOscillator: false,
        SimpleMASignal: false
      });
      const macdObj = macdArray[macdArray.length - 1];

      // Calculate Bollinger Bands (period=20, stdDev=2)
      const bbArray = technicalindicators.BollingerBands.calculate({
        period: 20,
        values: closes,
        stdDev: 2
      });
      const bb = bbArray[bbArray.length - 1];

      // Calculate ATR(14)
      const atrArray = technicalindicators.ATR.calculate({
        period: 14,
        high: highs,
        low: lows,
        close: closes
      });
      const atr = atrArray[atrArray.length - 1];

      // Calculate Stochastic (14, 3)
      const stochArray = technicalindicators.Stochastic.calculate({
        period: 14,
        signalPeriod: 3,
        high: highs,
        low: lows,
        close: closes
      });
      const stochObj = stochArray[stochArray.length - 1];

      // Compute VWAP manually
      const vwap = computeVWAP(data);

      // --------------------------
      // Derive individual indicator signals
      // --------------------------
      let signals = [];

      // EMA signal: if current price > EMA, bullish; else bearish.
      signals.push(currentPrice > ema9 ? 'buy' : 'sell');

      // RSI signal: if RSI < 30 => oversold (buy); if RSI > 70 => overbought (sell); else neutral.
      if (rsi < 30) signals.push('buy');
      else if (rsi > 70) signals.push('sell');
      else signals.push('neutral');

      // MACD signal: if MACD > signal line, bullish.
      signals.push(macdObj.MACD > macdObj.signal ? 'buy' : 'sell');

      // Bollinger Bands signal: if price below lower band, buy; if above upper band, sell; else neutral.
      if (currentPrice < bb.lower) signals.push('buy');
      else if (currentPrice > bb.upper) signals.push('sell');
      else signals.push('neutral');

      // ATR: Here we use ATR as a volatility filter. If ATR is above 1% of current price, we add a "confirm" signal.
      if (atr > (currentPrice * 0.01)) signals.push('confirm');
      else signals.push('neutral');

      // Stochastic signal: if %K < 20 and rising above %D, buy; if %K > 80 and falling below %D, sell; else neutral.
      if (stochObj.k < 20 && stochObj.k > stochObj.d) signals.push('buy');
      else if (stochObj.k > 80 && stochObj.k < stochObj.d) signals.push('sell');
      else signals.push('neutral');

      // VWAP signal: if current price > VWAP, bullish; else bearish.
      if (vwap !== null) {
        signals.push(currentPrice > vwap ? 'buy' : 'sell');
      } else {
        signals.push('neutral');
      }

      return { currentPrice, signals };
    }

    // ============================
    // Combine signals to produce a final decision
    // ============================
    function combineSignals(indicatorSignals) {
      // Count how many 'buy', 'sell', and 'neutral' signals we got
      let buyCount = 0, sellCount = 0, confirmCount = 0;
      indicatorSignals.forEach(sig => {
        if (sig === 'buy') buyCount++;
        else if (sig === 'sell') sellCount++;
        else if (sig === 'confirm') confirmCount++; // use confirm as extra weight
      });

      // For a strong move, we can require a weighted count.
      // Here we add 2 for each 'confirm' and require at least 5 (out of 7) for a decision.
      const totalBuy = buyCount + (confirmCount * 2);
      const totalSell = sellCount + (confirmCount * 2);

      if (totalBuy >= 5 && totalBuy > totalSell) return 'Buy';
      else if (totalSell >= 5 && totalSell > totalBuy) return 'Sell';
      else return 'No Entry';
    }

    // ============================
    // Main function: Fetch data, compute indicators, update the signal
    // ============================
    async function updateTradingSignal() {
      const data = await fetchTimeSeries();
      const signalEl = document.getElementById('signal');
      if (!data) {
        signalEl.textContent = 'No Entry';
        signalEl.className = 'signal no-entry';
        return;
      }

      const { currentPrice, signals } = determineIndicatorSignals(data);
      console.log('Indicators:', signals, 'Current Price:', currentPrice);
      const finalSignal = combineSignals(signals);

      // Update the page with the final signal
      if (finalSignal === 'Buy') {
        signalEl.textContent = 'Buy';
        signalEl.className = 'signal buy';
      } else if (finalSignal === 'Sell') {
        signalEl.textContent = 'Sell';
        signalEl.className = 'signal sell';
      } else {
        signalEl.textContent = 'No Entry';
        signalEl.className = 'signal no-entry';
      }
    }

    // Run on page load, then update every minute (60000 ms)
    updateTradingSignal();
    setInterval(updateTradingSignal, 60000);
  </script>
</body>
</html>
